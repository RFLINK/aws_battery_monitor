# センサーノード
- RTCをポーリングして１秒間隔で呼ばれる関数を設ける。
  ３秒毎に電圧を記録。
  １８０秒事に気温湿度を記録。

- 送信契機
  送信許可タイマーが３秒以上であれば、毎秒 3%（random(100)<3）の抽選を行い、当選したらデータ送信を行う。
  ACKが得られたら、すかさず次の送信を行う。
  ACKが得られなかったら、送信許可タイマーのループに戻る。（つまり次の１秒で抽選当選して再送もあり得る）
  他ノード宛のACKを受信したら、送信許可タイマーを０クリアする。

- 送信内容
  sequence_numberをデータ記録時のEPOC時間（UTC）/ 180 の値にセットしてＧＷへ送信してＡＣＫを待つ。
  つまり、センサーデータ３分の先頭の時刻 / 180 をシーケンス番号として使う。（データベース上でユニークなキーとして使われる。上書きは可能）

# LoRaゲートウェイ
- アップロード
  センサーノードのペイロードを以下のJSON形式に変換してMQTT battery-monitor/{gw-id}/up/data に Publish。
- ダウンロード
  MQTTの battery-monitor/{gw-id}/down/# を Subscribe。ACKを受信したら、指定の device_id にLoRa送信。

# GW->Serverへping送信（時間獲得）
- データベース更新なし。応答ACKのTimestampを利用してGWのRTCをセットするように使う。GWおよびセンサーノードはUTC時間で動作する事。（つまりJST補正しない）
```
{
  "destination": "ping",
  "gateway_id": "gw-001",
  "device_id": "device-abc",
  "sequence_number": 12345,
  "timestamp": 1714128000
}
```
# GW->Serverへdata送信
- もし、RSSIが-100以上であるなら、+100を加算し、残りの時間だけ送信前にDelay(ms)する。-130ならdelaymsec(30)となる。（電波強度が高い信号をうけとったGWを優先する措置）
```
{
  "destination": "server",
  "gateway_id": "gw-001",
  "device_id": "device-abc",
  "sequence_number": 12345,
  "timestamp": 1714128000,
  "rssi": -62,
  "voltages": [
    3.30, 3.28, 3.29, 3.30, 3.27, 3.31, 3.29, 3.30, 3.28, 3.30,
    3.29, 3.30, 3.28, 3.31, 3.29, 3.30, 3.27, 3.30, 3.29, 3.30,
    3.28, 3.31, 3.29, 3.30, 3.28, 3.30, 3.29, 3.31, 3.28, 3.30,
    3.29, 3.30, 3.28, 3.31, 3.27, 3.30, 3.29, 3.30, 3.28, 3.31,
    3.29, 3.30, 3.28, 3.30, 3.29, 3.31, 3.27, 3.30, 3.29, 3.30,
    3.28, 3.31, 3.29, 3.30, 3.28, 3.30, 3.29, 3.31, 3.28, 3.30
  ],
  "temperature": 24.8,
  "humidity": 58.2
}
```
# ACK信号
- ACKに含まれるtimestampは、Serverの現時刻。GWのRTC時間補正に使用する。UTC時刻であり、GWおよびセンサーノードもUTC時間で動作させること。
```
{
  "destination": "gateway",
  "gateway_id": "gw-001",
  "device_id": "device-abc",
  "sequence_number": 12347,
  "timestamp": 1746587152,
  "status": "ack"
}
```
